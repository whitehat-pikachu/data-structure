2.1 types and definition of linear list
item 
record
file
(a1, a2,...,an-1,an)
list

adt list{
  d={ai| ai∈Eleset, i=1,2,..,n,n>=0}
  R1={<ai-1,ai>|ai-1,ai∈D,i=2,...,n}
  InitList(&L)
  DestoryList(&L)
  ClearList(&L)
  ListEmpty(L)
  ListLength(L)
  GetElem(L,i,&e)
  LocateElem(L,e,compare())
  PriorElem(L,cur_e,&pre_e)
  NextElem(L,cur_e,&next_e)
  ListInsert(&L,i,e)
  ListDelete(&L,i,&e)
  ListTraverse(L,visit())  
} ADT List

void union(List &La, List Lb){
  La_Len=ListLength(La);
  Lb_Len=ListLength(Lb);
  for(i=1;i<=Lb_len;i++){
    GetElem(Lb,i,e);
    if(!LocateElem(La,e,equal)) ListInsert(La,++La_len,e);
  }
}

void MergeList(List La, List Lb, List&Lc){
  InitList(Lc);
  i=j=1;k=0;
  La_len=ListLength(La);
  Lb_len=ListLength(Lb);
  while((i<=La_len)&&(j<=Lb_len)){
    GetElem(La,i,ai);
    GetElem(Lb,j,bj);
    if(ai<=bj){ListInsert(Lc,++k,ai);++i;}
    else{ListInsert(Lc,++k,bj);++j;}
  }
while(i<=La_len){
  GetElem(La,i++,ai);
  ListInsert(Lc,++k,ai);
}
while(j<=Lb_len){
  GetElem(Lb,j++,bj);
  ListInsert(Lc,++k,bj);
}
}

2.2 sequence expression and realisation of linear List
LOC(ai+1)=LOC(ai)+l
LOC(ai)=LOC(a1)+(i-1)*l
sequential mapping

#define LIST_INT_SIZE 100   //initial quotien of linear List saving space
#define LISTINCREMENT       //quotien increment for linear List saving space
typeof struct{
  ElemType *elem;   //Address of saving spacee
  int length;       //Current length
  int listsize;     //saving space of current 
}SqList

Status InitList.Sq(SqList &L){
  //Create a empty Linear List
  L.elem=(ElemType *) malloc(LIST_INIT_SIZE *sizeof(ElemType));
  if(!L.elem)exit(OVERFLOW)   //failure for allocating saving space
  L.length=0;                 //empty linear list length=0
  L.listsize=LIST_INIT_SIZE   //initial saving space
  return OK;   
}//InitList_Sq

alogrithm 2.3
Status ListInsert_Sq(SqList &L, int i, ElemType e){
  //Insert new element i to the place i of Sequential linear list
  //the legal value of i is 1<=i<ListLength_Sq(L)+1
  if(i<1 | i>L.length+1) return ERROR;    //the value of i is illegal
  if(L.length>=L.listsize){     //the current saving space is full, add allocation
    newbase=(ElemType *)realloc(L.elem,
                  (L.listsize+LISTINCREMENT)*sizeof(ElemType));
    if(!newbase)exit(OVERFLOW)
  
  }
}


